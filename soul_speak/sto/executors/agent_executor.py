"""Executor that executes structured multi-step agent plans."""
from __future__ import annotations

import asyncio
import contextlib
import os
import shlex
from typing import Iterable, List, Mapping, Optional, Sequence

from attrs import define, field

from soul_speak.sto.executors.base import Executor
from soul_speak.sto.models import Task, TaskLog
from soul_speak.sto.store.interface import TaskStoreProtocol


@define
class AgentExecutor(Executor):
    """Replay deterministic plan steps generated by an upstream planner.

    Expected payload format:
        {
            "plan": [
                {"type": "command", "command": ["echo", "hi"], "timeout": 5},
                {"type": "sleep", "seconds": 1.0},
                {"type": "note", "message": "mark complete"}
            ],
            "env": {"EXAMPLE": "1"},        # optional shared env for commands
            "summary": "optional user-facing summary"
        }
    """

    supported_types: Iterable[str] = field(factory=lambda: {"agent_plan"})
    max_steps: int = 25
    default_command_timeout: float = 30.0
    allowed_commands: Iterable[str] = field(factory=tuple)
    base_env: Optional[Mapping[str, str]] = None
    stdout_log_limit: int = 2000
    stderr_log_limit: int = 2000

    def __attrs_post_init__(self) -> None:
        self.supported_types = set(self.supported_types)
        self.allowed_commands = {str(cmd) for cmd in self.allowed_commands}

    def can_handle(self, task: Task) -> bool:  # type: ignore[override]
        return task.type in self.supported_types

    async def execute(self, task: Task, store: TaskStoreProtocol) -> None:  # type: ignore[override]
        await self._mark_running(task, store)

        payload = task.payload or {}
        plan_steps = payload.get("plan")
        if not isinstance(plan_steps, Sequence):
            await self._finish_failed(task, store, "agent payload missing 'plan' steps")
            return

        if len(plan_steps) > self.max_steps:
            await self._finish_failed(task, store, f"plan exceeds max steps ({self.max_steps})")
            return

        base_env = payload.get("env")
        if base_env is not None and not isinstance(base_env, Mapping):
            await self._finish_failed(task, store, "env must be a mapping of environment overrides")
            return

        step_results: List[str] = []

        for index, raw_step in enumerate(plan_steps, start=1):
            if not isinstance(raw_step, Mapping):
                await self._finish_failed(task, store, f"step {index} must be a mapping")
                return

            step_type = str(raw_step.get("type") or "note").lower()
            if step_type == "command":
                command = raw_step.get("command")
                if not command:
                    await self._finish_failed(task, store, f"step {index} missing command")
                    return
                args_list: Sequence[str]
                if isinstance(command, str):
                    args_list = tuple(shlex.split(command))
                elif isinstance(command, Sequence):
                    args_list = tuple(str(part) for part in command)
                else:
                    await self._finish_failed(task, store, f"step {index} command must be string or sequence")
                    return

                if not args_list:
                    await self._finish_failed(task, store, f"step {index} command resolved empty")
                    return

                head = args_list[0]
                if self.allowed_commands and head not in self.allowed_commands:
                    await self._finish_failed(
                        task,
                        store,
                        f"step {index} command {head} not allowed by AgentExecutor policy",
                    )
                    return

                timeout_value = raw_step.get("timeout", self.default_command_timeout)
                try:
                    timeout = float(timeout_value)
                except (TypeError, ValueError):
                    await self._finish_failed(task, store, f"step {index} timeout must be numeric")
                    return
                if timeout <= 0:
                    await self._finish_failed(task, store, f"step {index} timeout must be > 0")
                    return

                step_env = raw_step.get("env")
                if step_env is not None and not isinstance(step_env, Mapping):
                    await self._finish_failed(task, store, f"step {index} env must be mapping")
                    return

                self._log_step(
                    store,
                    task,
                    index,
                    "command",
                    {"command": " ".join(args_list), "timeout": timeout},
                )

                stdout, stderr, returncode = await self._run_command(args_list, step_env, timeout)
                task_store_details = {
                    "command": " ".join(args_list),
                    "returncode": returncode,
                }
                if stdout:
                    task_store_details["stdout"] = stdout[: self.stdout_log_limit]
                if stderr:
                    task_store_details["stderr"] = stderr[: self.stderr_log_limit]
                self._log_step(store, task, index, "command_result", task_store_details)
                if returncode != 0:
                    await self._finish_failed(task, store, f"step {index} command exited with {returncode}")
                    return

                step_results.append(f"{index}. command: {' '.join(args_list)}")

            elif step_type == "sleep":
                seconds_value = raw_step.get("seconds", raw_step.get("duration"))
                try:
                    seconds = float(seconds_value)
                except (TypeError, ValueError):
                    await self._finish_failed(task, store, f"step {index} sleep seconds invalid")
                    return
                if seconds < 0:
                    await self._finish_failed(task, store, f"step {index} sleep seconds must be >= 0")
                    return
                self._log_step(store, task, index, "sleep", {"seconds": seconds})
                await asyncio.sleep(seconds)
                step_results.append(f"{index}. sleep {seconds:.2f}s")

            else:
                message = str(raw_step.get("message") or raw_step.get("note") or "")
                self._log_step(store, task, index, "note", {"message": message})
                step_results.append(f"{index}. note: {message}")

        summary = payload.get("summary") or "; ".join(step_results)
        task.result = {"summary": summary, "steps": step_results}
        await self._finish_success(task, store, result=summary)

    def _log_step(
        self,
        store: TaskStoreProtocol,
        task: Task,
        index: int,
        step_type: str,
        details: Mapping[str, object],
    ) -> None:
        store.append_log(
            TaskLog(
                task_id=task.id,
                event=f"agent_step_{step_type}",
                message=f"step {index}: {step_type}",
                details=dict(details),
            )
        )

    async def _run_command(
        self,
        args_list: Sequence[str],
        step_env: Optional[Mapping[str, str]],
        timeout: float,
    ) -> tuple[str, str, int]:
        env_vars = {**os.environ}
        if self.base_env:
            env_vars.update({str(k): str(v) for k, v in self.base_env.items()})
        if step_env:
            env_vars.update({str(k): str(v) for k, v in step_env.items()})

        process = await asyncio.create_subprocess_exec(
            *args_list,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            env=env_vars,
        )
        try:
            stdout_bytes, stderr_bytes = await asyncio.wait_for(process.communicate(), timeout=timeout)
        except asyncio.TimeoutError:
            process.kill()
            with contextlib.suppress(Exception):  # type: ignore[name-defined]
                await process.communicate()
            return "", "", -1

        stdout_text = stdout_bytes.decode("utf-8", errors="replace")
        stderr_text = stderr_bytes.decode("utf-8", errors="replace")
        return stdout_text, stderr_text, process.returncode


__all__ = ["AgentExecutor"]
